use regex::Regex;

pub fn grammer() {
    //
    //  .            除新行以外的任何字符(包括带有 s 标志的新行)
    //  \d           数字 （\p{Nd})
    //  \D           非数字
    //  \pN          单字母名称 Unicode 字符类
    //  \PN          Negated(非)  单字母名称 Unicode 字符类
    //  \p{Greek}    Unicode字符类(常规类别或脚本)
    //  \P{Greek}    negated(非) Unicode字符类(常规类别或脚本)
    //  [xyz]        匹配x, y 或 z(并集)的字符类
    //  [^xyz]       匹配除x, y 和 z 以外的任何字符的字符类
    //  [a-z]        匹配a-z范围内的任何字符的字符类
    //  [[:alpha:]]  ASCII 字符类[a-zA-Z]
    //  [[:^alpha:]] Negated(非) ASCII 字符类([^A-Za-z])
    //  [x[^xyz]]    嵌套/分组字符类(匹配除y和z以外的任何字符)
    //  [a-y&&xyz]   交集(匹配x和y)
    //  [0-9&&[^4]]  使用交集和求反的减法(匹配0-9之间除了4之外的数字)
    //  [0-9--4]     直接减法(匹配0-9之间除了4之外的其他数字)
    //  [a-g~~b-h]   对称差异(范围或异-- 仅匹配`a` 和 `h`)
    //  [\[\]]       字符中的转义(匹配`[` 或者 `]`)
    //
    //  ---------------------------------------------------------------------
    //  xy           串联
    //  x|y          交替(x or y, 优先 x)
    //
    //  ---------------------------------------------------------------------
    //  >  重复项匹配
    //  x*           [0~n] 个x (贪婪)
    //  x+           [1~n] 个x (贪婪)
    //  x?           [0~1] 个x (贪婪)
    //  x*?          [1~n] 个x (懒惰)
    //  x+?          [1~n] 个x (懒惰)
    //  x??          [0~1] 个x (懒惰)
    //  x{n,m}       [n~m] 个x (贪婪)
    //  x{n,}        >= n 个x (贪婪)
    //  x{n}         n 个x (贪婪)
    //  x{n,m}?      [n,m] 个x (懒惰)
    //  x{n,}?       >= n 个x (懒惰)
    //
    //  ---------------------------------------------------------------------
    //  > 边界
    //  ^            文本开头(多行模式下的行首)
    //  $            文本结尾(多行模式下的行尾)
    //  \A           仅文本开头(即使启用多行模式)
    //  \z           仅文本结尾(即使启用多行模式)
    //  \b           Unicode 单词边界(一侧是\w, 另一侧是\W, \A 或 \z)
    //  \B           非 Unicode 单词的边界
    //
    //  --------------------------------------------------------------------
    //  > 元子组
    //  (epx)        编号捕获组
    //  (?<name>epx) 命名(或编号) 捕获组(允许的字符[_0-9a-zA-Z.\[\]])
    //  (?:exp)      非捕获组
    //  (?flags)     在当前组中设置标志
    //  (?flags:exp) 为exp(非捕获) 设置标志
    //
    //  -------------------------------------------------------------------
    //  > 可以设置的标志（默认所有的标志都是关闭的)
    //  i            不区分大小写
    //  m            多行模式，^ 和 $ 匹配行首和行尾
    //  s            允许 `.` 匹配换行符`\n`
    //  U            交换 X* 和 X*?
    //  u            Unicode 字符支持，默认启用
    //  x            忽略空白并允许行注释(以`#`开头)
    //
    let grammer = Regex::new(r"\d+").unwrap();
    println!("{}", grammer.find("hello").unwrap().as_str())
}

// 在一个表达式中使用多个默认
pub fn change_flag_in_mode() {
    // 匹配 a 的时候会忽略大小写，匹配 B 的时候需要匹配大小写
    let re = Regex::new(r"(?i)a+(?-i)b+").unwrap();
    let cap = re.captures("AaAaAbbBBBb").unwrap();
    assert_eq!(&cap[0], "AaAaAbb");
}

// 多行模式匹配
pub fn mulltiline_mode() {
    let re = Regex::new(r"(?m)^line \d+").unwrap();
    let m = re.find("line one\nline 2\n").unwrap();
    assert_eq!(m.as_str(), "line 2");
}
